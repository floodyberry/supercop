/*This program gives the optimized SSE2 bitslice implementation of JH for 64-bit platform (with 16 128-bit XMM registers).

   --------------------------------
   Performance

   Microprocessor: Intel CORE 2 processor (Core 2 Duo Mobile P9400 2.53GHz) running 64-bit Debian 5.0: 
   Operating System: 64-bit Debian 5.0 (Linux kernel 2.6.26-2-amd64)
   Speed for long message:
   1) 16.1 cycle/byte   compiler: Intel C++ compiler 11.1   compilation option: icc -fast
   2) 17.0 cycles/byte  compiler: gcc 4.3.2                 compilation option: gcc -msse2 -O3  

   Microprocessor: Intel CORE 2 processor (Core 2 Quad Q6600 2.4GHz) 
   Operating System: 64-bit Windows Vista Business
   Speed for long message:
   3) 17.4 cycles/byte  compiler: Intel C++ compiler 11.1    compilation option: icl /O2
   4) 18.9 cycles/byte  compiler: Microsoft Visual C++ 2008  compilation option: release

   --------------------------------
   Compare with the original JH sse2 code (October 2008) for 64-bit platform, we made the modifications:
   a) The Sbox implementation simply follows the description given in the document
   b) Data alignment definition is improved so that the code can be compiled by GCC, Intel C++ compiler and Microsoft Visual C compiler
   c) Using y0,y1,..,y7 variables in Function F8 for performance improvement (local variable in function F8 so that compiler can optimize the code easily)
   d) Removed a number of intermediate variables from the program (so as to give compiler more freedom to optimize the code) 
   e) Using "for" loop to implement 35 rounds (with 7 rounds in each loop), so as to reduce the code size. 
   
   --------------------------------
   Last Modified: December 08, 2009     
*/



#include <emmintrin.h>
#include <string.h>

typedef unsigned long long uint64;
typedef __m128i  word128;   /*word128 defines a 128-bit SSE2 word*/

typedef unsigned char BitSequence;
typedef unsigned long long DataLength; 
typedef enum {SUCCESS = 0, FAIL = 1, BAD_HASHLEN = 2} HashReturn;

/*define data alignment for different C compilers*/
#if defined(__GNUC__)
      #define DATA_ALIGN16(x) x __attribute__ ((aligned(16)))
#else
      #define DATA_ALIGN16(x) __declspec(align(16)) x
#endif

typedef struct {
      int hashbitlen;	                /*the message digest size*/
      unsigned long long databitlen;    /*the message size in bits*/
      word128  x0,x1,x2,x3,x4,x5,x6,x7; /*1024-bit state;*/
      unsigned char buffer[64];         /*512-bit message block;*/
} hashState;

/*The initial hash value H(0)*/
DATA_ALIGN16(const unsigned char JH224_H0[128])={0x82,0xc2,0x70,0xe0,0xb,0xed,0x2,0x30,0x8d,0xc,0x3a,0x9e,0x31,0xce,0x34,0xb1,0x8f,0xc,0x94,0x2f,0xba,0x46,0xcd,0x87,0x1e,0xc4,0xd8,0xa,0xfc,0x79,0x71,0xc4,0x61,0xe0,0x1a,0xbb,0x69,0x96,0x2d,0x7b,0xaf,0x71,0x89,0x3d,0xe1,0x3d,0x86,0x97,0xd2,0x52,0x4,0x60,0xf7,0xc9,0xc0,0x94,0xc7,0x63,0x49,0xca,0x3d,0xa5,0x79,0x9c,0xfd,0x8b,0x55,0x1f,0xbd,0xbc,0xeb,0x9f,0x8,0x34,0xbd,0x5b,0xb4,0x42,0xf8,0xbf,0xba,0x51,0x5c,0x35,0xb9,0xc7,0x99,0x9e,0x55,0xa4,0x4e,0x62,0x71,0xcc,0x13,0xb3,0x85,0x72,0x57,0x93,0xc1,0x85,0xf7,0x25,0x45,0x36,0x6b,0x69,0x0,0x50,0x25,0xd2,0x33,0x90,0xeb,0xdb,0x27,0xdd,0x1e,0xdf,0xcc,0xba,0xad,0xe1,0x7e,0x60,0x3d,0xe9};
DATA_ALIGN16(const unsigned char JH256_H0[128])={0xc9,0x68,0xb8,0xe2,0xc5,0x3a,0x59,0x6e,0x42,0x7e,0x45,0xef,0x1d,0x7a,0xe6,0xe5,0x61,0x45,0xb7,0xd9,0x6,0x71,0x1f,0x7a,0x2f,0xc7,0x61,0x78,0x6,0xa9,0x22,0x1,0x7b,0x29,0x91,0xc1,0xb9,0x19,0x29,0xe2,0xc4,0x2b,0x4c,0xe1,0x8c,0xc5,0xa2,0xd6,0x62,0x20,0xbe,0xca,0x90,0x1b,0x5d,0xdf,0xd3,0xb2,0x5,0x63,0x8e,0xa7,0xac,0x5f,0x14,0x3e,0x8c,0xba,0x6d,0x31,0x31,0x4,0xb0,0xe7,0x0,0x54,0x90,0x52,0x72,0x71,0x4c,0xce,0x32,0x1e,0x7,0x5d,0xe5,0x10,0x1b,0xa8,0x0,0xec,0xe2,0x2,0x51,0x78,0x9f,0x57,0x72,0x79,0x5f,0xd1,0x4,0xa5,0xf0,0xb8,0xb6,0x34,0x25,0xf5,0xb2,0x38,0x16,0x70,0xfa,0x3e,0x5f,0x90,0x7f,0x17,0xe2,0x8f,0xc0,0x64,0xe7,0x69,0xac,0x90};
DATA_ALIGN16(const unsigned char JH384_H0[128])={0x7,0x9c,0x23,0xab,0x64,0xab,0x2d,0x40,0x8c,0xb5,0x1c,0xe4,0x47,0xde,0xe9,0x8d,0x8d,0x9b,0xb1,0x62,0x7e,0xc2,0x52,0x69,0xba,0xb6,0x2d,0x2b,0x0,0x2f,0xfc,0x80,0xcb,0xaf,0xbc,0xef,0x30,0x8c,0x17,0x3a,0xad,0x6f,0xa3,0xaa,0x31,0x19,0x40,0x31,0x89,0x89,0x77,0x42,0x3a,0x6f,0x4c,0xe3,0xbf,0x2e,0x73,0x2b,0x44,0xd,0xdb,0x7d,0xf2,0xc4,0x3e,0xca,0xa6,0x3a,0x54,0xe5,0x8a,0x37,0xb8,0xa,0xfc,0x44,0x22,0xc5,0xa3,0x97,0xc3,0xbc,0x4,0xe9,0xe0,0x91,0x37,0xa8,0x4,0x53,0xe1,0x48,0x60,0xfa,0x71,0x31,0xd3,0x3a,0x5f,0xd4,0xbe,0xa6,0xdc,0xda,0x4a,0xf8,0xf4,0x33,0x85,0x12,0x6e,0xc7,0xf8,0xf4,0xc8,0x49,0x58,0xd0,0x8b,0x9e,0x94,0xa3,0x46,0x95,0xb6,0xa9};
DATA_ALIGN16(const unsigned char JH512_H0[128])={0x50,0xab,0x60,0x58,0xc6,0x9,0x42,0xcc,0x4c,0xe7,0xa5,0x4c,0xbd,0xb9,0xdc,0x1b,0xaf,0x2e,0x7a,0xfb,0xd1,0xa1,0x5e,0x24,0xe5,0xf4,0x4e,0xab,0xc4,0xd5,0xc0,0xa1,0x4c,0xf2,0x43,0x66,0xc,0x56,0x20,0x73,0x99,0x93,0x81,0xea,0x9a,0x8b,0x3d,0x18,0xcf,0x65,0xd9,0xfc,0xa9,0x40,0xb6,0xc7,0x9e,0x83,0x12,0x73,0xbe,0xfe,0x3b,0x66,0xf,0x9a,0x2f,0x7e,0xa,0x32,0xd8,0xe0,0x17,0xd4,0x91,0x55,0x8e,0xb,0x13,0x40,0x5,0xb5,0xe4,0xde,0xc4,0x4e,0x5f,0x3f,0x8c,0xbc,0x5a,0xee,0x98,0xfd,0x1d,0x32,0x14,0x8,0x1c,0x25,0xe4,0x6c,0xe6,0xc4,0x1b,0x4b,0x95,0xbc,0xe1,0xbd,0x43,0xdb,0x7f,0x22,0x9e,0xc2,0x43,0xb6,0x80,0x14,0xa,0x33,0xb9,0x9,0x33,0x3c,0x3,0x3};

/*36 round constants, each round constant is 32-byte (256-bit)*/
DATA_ALIGN16(const unsigned char E8_bitslice_roundconstant[36][32])={
{0x72,0xd5,0xde,0xa2,0xdf,0x15,0xf8,0x67,0x7b,0x84,0x15,0xa,0xb7,0x23,0x15,0x57,0x81,0xab,0xd6,0x90,0x4d,0x5a,0x87,0xf6,0x4e,0x9f,0x4f,0xc5,0xc3,0xd1,0x2b,0x40},
{0xea,0x98,0x3a,0xe0,0x5c,0x45,0xfa,0x9c,0x3,0xc5,0xd2,0x99,0x66,0xb2,0x99,0x9a,0x66,0x2,0x96,0xb4,0xf2,0xbb,0x53,0x8a,0xb5,0x56,0x14,0x1a,0x88,0xdb,0xa2,0x31},
{0x3,0xa3,0x5a,0x5c,0x9a,0x19,0xe,0xdb,0x40,0x3f,0xb2,0xa,0x87,0xc1,0x44,0x10,0x1c,0x5,0x19,0x80,0x84,0x9e,0x95,0x1d,0x6f,0x33,0xeb,0xad,0x5e,0xe7,0xcd,0xdc},
{0x10,0xba,0x13,0x92,0x2,0xbf,0x6b,0x41,0xdc,0x78,0x65,0x15,0xf7,0xbb,0x27,0xd0,0xa,0x2c,0x81,0x39,0x37,0xaa,0x78,0x50,0x3f,0x1a,0xbf,0xd2,0x41,0x0,0x91,0xd3},
{0x42,0x2d,0x5a,0xd,0xf6,0xcc,0x7e,0x90,0xdd,0x62,0x9f,0x9c,0x92,0xc0,0x97,0xce,0x18,0x5c,0xa7,0xb,0xc7,0x2b,0x44,0xac,0xd1,0xdf,0x65,0xd6,0x63,0xc6,0xfc,0x23},
{0x97,0x6e,0x6c,0x3,0x9e,0xe0,0xb8,0x1a,0x21,0x5,0x45,0x7e,0x44,0x6c,0xec,0xa8,0xee,0xf1,0x3,0xbb,0x5d,0x8e,0x61,0xfa,0xfd,0x96,0x97,0xb2,0x94,0x83,0x81,0x97},
{0x4a,0x8e,0x85,0x37,0xdb,0x3,0x30,0x2f,0x2a,0x67,0x8d,0x2d,0xfb,0x9f,0x6a,0x95,0x8a,0xfe,0x73,0x81,0xf8,0xb8,0x69,0x6c,0x8a,0xc7,0x72,0x46,0xc0,0x7f,0x42,0x14},
{0xc5,0xf4,0x15,0x8f,0xbd,0xc7,0x5e,0xc4,0x75,0x44,0x6f,0xa7,0x8f,0x11,0xbb,0x80,0x52,0xde,0x75,0xb7,0xae,0xe4,0x88,0xbc,0x82,0xb8,0x0,0x1e,0x98,0xa6,0xa3,0xf4},
{0x8e,0xf4,0x8f,0x33,0xa9,0xa3,0x63,0x15,0xaa,0x5f,0x56,0x24,0xd5,0xb7,0xf9,0x89,0xb6,0xf1,0xed,0x20,0x7c,0x5a,0xe0,0xfd,0x36,0xca,0xe9,0x5a,0x6,0x42,0x2c,0x36},
{0xce,0x29,0x35,0x43,0x4e,0xfe,0x98,0x3d,0x53,0x3a,0xf9,0x74,0x73,0x9a,0x4b,0xa7,0xd0,0xf5,0x1f,0x59,0x6f,0x4e,0x81,0x86,0xe,0x9d,0xad,0x81,0xaf,0xd8,0x5a,0x9f},
{0xa7,0x5,0x6,0x67,0xee,0x34,0x62,0x6a,0x8b,0xb,0x28,0xbe,0x6e,0xb9,0x17,0x27,0x47,0x74,0x7,0x26,0xc6,0x80,0x10,0x3f,0xe0,0xa0,0x7e,0x6f,0xc6,0x7e,0x48,0x7b},
{0xd,0x55,0xa,0xa5,0x4a,0xf8,0xa4,0xc0,0x91,0xe3,0xe7,0x9f,0x97,0x8e,0xf1,0x9e,0x86,0x76,0x72,0x81,0x50,0x60,0x8d,0xd4,0x7e,0x9e,0x5a,0x41,0xf3,0xe5,0xb0,0x62},
{0xfc,0x9f,0x1f,0xec,0x40,0x54,0x20,0x7a,0xe3,0xe4,0x1a,0x0,0xce,0xf4,0xc9,0x84,0x4f,0xd7,0x94,0xf5,0x9d,0xfa,0x95,0xd8,0x55,0x2e,0x7e,0x11,0x24,0xc3,0x54,0xa5},
{0x5b,0xdf,0x72,0x28,0xbd,0xfe,0x6e,0x28,0x78,0xf5,0x7f,0xe2,0xf,0xa5,0xc4,0xb2,0x5,0x89,0x7c,0xef,0xee,0x49,0xd3,0x2e,0x44,0x7e,0x93,0x85,0xeb,0x28,0x59,0x7f},
{0x70,0x5f,0x69,0x37,0xb3,0x24,0x31,0x4a,0x5e,0x86,0x28,0xf1,0x1d,0xd6,0xe4,0x65,0xc7,0x1b,0x77,0x4,0x51,0xb9,0x20,0xe7,0x74,0xfe,0x43,0xe8,0x23,0xd4,0x87,0x8a},
{0x7d,0x29,0xe8,0xa3,0x92,0x76,0x94,0xf2,0xdd,0xcb,0x7a,0x9,0x9b,0x30,0xd9,0xc1,0x1d,0x1b,0x30,0xfb,0x5b,0xdc,0x1b,0xe0,0xda,0x24,0x49,0x4f,0xf2,0x9c,0x82,0xbf},
{0xa4,0xe7,0xba,0x31,0xb4,0x70,0xbf,0xff,0xd,0x32,0x44,0x5,0xde,0xf8,0xbc,0x48,0x3b,0xae,0xfc,0x32,0x53,0xbb,0xd3,0x39,0x45,0x9f,0xc3,0xc1,0xe0,0x29,0x8b,0xa0},
{0xe5,0xc9,0x5,0xfd,0xf7,0xae,0x9,0xf,0x94,0x70,0x34,0x12,0x42,0x90,0xf1,0x34,0xa2,0x71,0xb7,0x1,0xe3,0x44,0xed,0x95,0xe9,0x3b,0x8e,0x36,0x4f,0x2f,0x98,0x4a},
{0x88,0x40,0x1d,0x63,0xa0,0x6c,0xf6,0x15,0x47,0xc1,0x44,0x4b,0x87,0x52,0xaf,0xff,0x7e,0xbb,0x4a,0xf1,0xe2,0xa,0xc6,0x30,0x46,0x70,0xb6,0xc5,0xcc,0x6e,0x8c,0xe6},
{0xa4,0xd5,0xa4,0x56,0xbd,0x4f,0xca,0x0,0xda,0x9d,0x84,0x4b,0xc8,0x3e,0x18,0xae,0x73,0x57,0xce,0x45,0x30,0x64,0xd1,0xad,0xe8,0xa6,0xce,0x68,0x14,0x5c,0x25,0x67},
{0xa3,0xda,0x8c,0xf2,0xcb,0xe,0xe1,0x16,0x33,0xe9,0x6,0x58,0x9a,0x94,0x99,0x9a,0x1f,0x60,0xb2,0x20,0xc2,0x6f,0x84,0x7b,0xd1,0xce,0xac,0x7f,0xa0,0xd1,0x85,0x18},
{0x32,0x59,0x5b,0xa1,0x8d,0xdd,0x19,0xd3,0x50,0x9a,0x1c,0xc0,0xaa,0xa5,0xb4,0x46,0x9f,0x3d,0x63,0x67,0xe4,0x4,0x6b,0xba,0xf6,0xca,0x19,0xab,0xb,0x56,0xee,0x7e},
{0x1f,0xb1,0x79,0xea,0xa9,0x28,0x21,0x74,0xe9,0xbd,0xf7,0x35,0x3b,0x36,0x51,0xee,0x1d,0x57,0xac,0x5a,0x75,0x50,0xd3,0x76,0x3a,0x46,0xc2,0xfe,0xa3,0x7d,0x70,0x1},
{0xf7,0x35,0xc1,0xaf,0x98,0xa4,0xd8,0x42,0x78,0xed,0xec,0x20,0x9e,0x6b,0x67,0x79,0x41,0x83,0x63,0x15,0xea,0x3a,0xdb,0xa8,0xfa,0xc3,0x3b,0x4d,0x32,0x83,0x2c,0x83},
{0xa7,0x40,0x3b,0x1f,0x1c,0x27,0x47,0xf3,0x59,0x40,0xf0,0x34,0xb7,0x2d,0x76,0x9a,0xe7,0x3e,0x4e,0x6c,0xd2,0x21,0x4f,0xfd,0xb8,0xfd,0x8d,0x39,0xdc,0x57,0x59,0xef},
{0x8d,0x9b,0xc,0x49,0x2b,0x49,0xeb,0xda,0x5b,0xa2,0xd7,0x49,0x68,0xf3,0x70,0xd,0x7d,0x3b,0xae,0xd0,0x7a,0x8d,0x55,0x84,0xf5,0xa5,0xe9,0xf0,0xe4,0xf8,0x8e,0x65},
{0xa0,0xb8,0xa2,0xf4,0x36,0x10,0x3b,0x53,0xc,0xa8,0x7,0x9e,0x75,0x3e,0xec,0x5a,0x91,0x68,0x94,0x92,0x56,0xe8,0x88,0x4f,0x5b,0xb0,0x5c,0x55,0xf8,0xba,0xbc,0x4c},
{0xe3,0xbb,0x3b,0x99,0xf3,0x87,0x94,0x7b,0x75,0xda,0xf4,0xd6,0x72,0x6b,0x1c,0x5d,0x64,0xae,0xac,0x28,0xdc,0x34,0xb3,0x6d,0x6c,0x34,0xa5,0x50,0xb8,0x28,0xdb,0x71},
{0xf8,0x61,0xe2,0xf2,0x10,0x8d,0x51,0x2a,0xe3,0xdb,0x64,0x33,0x59,0xdd,0x75,0xfc,0x1c,0xac,0xbc,0xf1,0x43,0xce,0x3f,0xa2,0x67,0xbb,0xd1,0x3c,0x2,0xe8,0x43,0xb0},
{0x33,0xa,0x5b,0xca,0x88,0x29,0xa1,0x75,0x7f,0x34,0x19,0x4d,0xb4,0x16,0x53,0x5c,0x92,0x3b,0x94,0xc3,0xe,0x79,0x4d,0x1e,0x79,0x74,0x75,0xd7,0xb6,0xee,0xaf,0x3f},
{0xea,0xa8,0xd4,0xf7,0xbe,0x1a,0x39,0x21,0x5c,0xf4,0x7e,0x9,0x4c,0x23,0x27,0x51,0x26,0xa3,0x24,0x53,0xba,0x32,0x3c,0xd2,0x44,0xa3,0x17,0x4a,0x6d,0xa6,0xd5,0xad},
{0xb5,0x1d,0x3e,0xa6,0xaf,0xf2,0xc9,0x8,0x83,0x59,0x3d,0x98,0x91,0x6b,0x3c,0x56,0x4c,0xf8,0x7c,0xa1,0x72,0x86,0x60,0x4d,0x46,0xe2,0x3e,0xcc,0x8,0x6e,0xc7,0xf6},
{0x2f,0x98,0x33,0xb3,0xb1,0xbc,0x76,0x5e,0x2b,0xd6,0x66,0xa5,0xef,0xc4,0xe6,0x2a,0x6,0xf4,0xb6,0xe8,0xbe,0xc1,0xd4,0x36,0x74,0xee,0x82,0x15,0xbc,0xef,0x21,0x63},
{0xfd,0xc1,0x4e,0xd,0xf4,0x53,0xc9,0x69,0xa7,0x7d,0x5a,0xc4,0x6,0x58,0x58,0x26,0x7e,0xc1,0x14,0x16,0x6,0xe0,0xfa,0x16,0x7e,0x90,0xaf,0x3d,0x28,0x63,0x9d,0x3f},
{0xd2,0xc9,0xf2,0xe3,0x0,0x9b,0xd2,0xc,0x5f,0xaa,0xce,0x30,0xb7,0xd4,0xc,0x30,0x74,0x2a,0x51,0x16,0xf2,0xe0,0x32,0x98,0xd,0xeb,0x30,0xd8,0xe3,0xce,0xf8,0x9a},
{0x4b,0xc5,0x9e,0x7b,0xb5,0xf1,0x79,0x92,0xff,0x51,0xe6,0x6e,0x4,0x86,0x68,0xd3,0x9b,0x23,0x4d,0x57,0xe6,0x96,0x67,0x31,0xcc,0xe6,0xa6,0xf3,0x17,0xa,0x75,0x5}};

void F8(hashState *state);    /* the compression function F8 */

/*The API functions*/
HashReturn Init(hashState *state, int hashbitlen);
HashReturn Update(hashState *state, const BitSequence *data, DataLength databitlen);
HashReturn Final(hashState *state, BitSequence *hashval);
HashReturn Hash(int hashbitlen, const BitSequence *data,DataLength databitlen, BitSequence *hashval);

/*The following defines operations on 128-bit word(s)*/
#define CONSTANT(b)   _mm_set1_epi8((b))          /*set each byte in a 128-bit register to be "b"*/

#define XOR(x,y)      _mm_xor_si128((x),(y))      /*XOR(x,y) = x ^ y, where x and y are two 128-bit word*/
#define AND(x,y)      _mm_and_si128((x),(y))      /*AND(x,y) = x & y, where x and y are two 128-bit word*/
#define ANDNOT(x,y)   _mm_andnot_si128((x),(y))   /*ANDNOT(x,y) = (!x) & y, where x and y are two 128-bit word*/
#define OR(x,y)       _mm_or_si128((x),(y))       /*OR(x,y)  = x | y, where x and y are two 128-bit word*/

#define SHR1(x)       _mm_srli_epi16((x), 1)      /*SHR1(x)  = x >> 1, where x is a 128 bit word*/
#define SHR2(x)       _mm_srli_epi16((x), 2)      /*SHR2(x)  = x >> 2, where x is a 128 bit word*/
#define SHR4(x)       _mm_srli_epi16((x), 4)      /*SHR4(x)  = x >> 4, where x is a 128 bit word*/
#define SHR8(x)       _mm_slli_epi16((x), 8)      /*SHR8(x)  = x >> 8, where x is a 128 bit word*/
#define SHR16(x)      _mm_slli_epi32((x), 16)     /*SHR16(x) = x >> 16, where x is a 128 bit word*/
#define SHR32(x)      _mm_slli_epi64((x), 32)     /*SHR32(x) = x >> 32, where x is a 128 bit word*/
#define SHR64(x)      _mm_slli_si128((x), 8)      /*SHR64(x) = x >> 64, where x is a 128 bit word*/

#define SHL1(x)       _mm_slli_epi16((x), 1)      /*SHL1(x)  = x << 1, where x is a 128 bit word*/
#define SHL2(x)       _mm_slli_epi16((x), 2)	  /*SHL2(x)  = x << 2, where x is a 128 bit word*/
#define SHL4(x)       _mm_slli_epi16((x), 4)	  /*SHL4(x)  = x << 4, where x is a 128 bit word*/
#define SHL8(x)       _mm_srli_epi16((x), 8)	  /*SHL8(x)  = x << 8, where x is a 128 bit word*/
#define SHL16(x)      _mm_srli_epi32((x), 16)	  /*SHL16(x) = x << 16, where x is a 128 bit word*/
#define SHL32(x)      _mm_srli_epi64((x), 32)	  /*SHL32(x) = x << 32, where x is a 128 bit word*/
#define SHL64(x)      _mm_srli_si128((x), 8)	  /*SHL64(x) = x << 64, where x is a 128 bit word*/

#define SWAP1(x)      OR(SHR1(AND((x),CONSTANT(0xaa))),SHL1(AND((x),CONSTANT(0x55))))  /*swapping bit 2i with bit 2i+1 of the 128-bit x */       
#define SWAP2(x)      OR(SHR2(AND((x),CONSTANT(0xcc))),SHL2(AND((x),CONSTANT(0x33))))  /*swapping bit 4i||4i+1 with bit 4i+2||4i+3 of the 128-bit x */
#define SWAP4(x)      OR(SHR4(AND((x),CONSTANT(0xf0))),SHL4(AND((x),CONSTANT(0xf))))   /*swapping bits 8i||8i+1||8i+2||8i+3 with bits 8i+4||8i+5||8i+6||8i+7 of the 128-bit x */    
#define SWAP8(x)      OR(SHR8(x),SHL8(x))                          /*swapping bits 16i||16i+1||...||16i+7 with bits 16i+8||16i+9||...||16i+15 of the 128-bit x */
#define SWAP16(x)     OR(SHR16(x),SHL16(x))                        /*swapping bits 32i||32i+1||...||32i+15 with bits 32i+16||32i+17||...||32i+31 of the 128-bit x */
#define SWAP32(x)     _mm_shuffle_epi32((x),_MM_SHUFFLE(2,3,0,1))  /*swapping bits 64i||64i+1||...||64i+31 with bits 64i+32||64i+33||...||64i+63 of the 128-bit x*/
#define SWAP64(x)     _mm_shuffle_epi32((x),_MM_SHUFFLE(1,0,3,2))  /*swapping bits 128i||128i+1||...||128i+63 with bits 128i+64||128i+65||...||128i+127 of the 128-bit x*/
#define STORE(x,p)    _mm_store_si128((__m128i *)(p), (x))         /*store the 128-bit word x into memeory address p, where p is the multile of 16 bytes*/    
#define LOAD(p)       _mm_load_si128((__m128i *)(p))               /*load 16 bytes from the memory address p, return a 128-bit word, where p is the multile of 16 bytes*/

/*The MDS code*/
#define L(m0,m1,m2,m3,m4,m5,m6,m7)     \
      (m4) = XOR((m4),(m1));           \
      (m5) = XOR((m5),(m2));           \
      (m6) = XOR(XOR((m6),(m3)),(m0)); \
      (m7) = XOR((m7),(m0));           \
      (m0) = XOR((m0),(m5));           \
      (m1) = XOR((m1),(m6));           \
      (m2) = XOR(XOR((m2),(m7)),(m4)); \
      (m3) = XOR((m3),(m4)); 

/*Two Sboxes computed in parallel, each Sbox implements S0 and S1, selected by a constant bit*/
/*The reason to compute two Sboxes in parallel is to try to fully utilize the parallel processing power of SSE2 instructions*/
#define SS(m0,m1,m2,m3,m4,m5,m6,m7,constant0,constant1)  \
      m3 = XOR(m3,CONSTANT(0xff));       \
      m7 = XOR(m7,CONSTANT(0xff));       \
      m0 = XOR(m0,ANDNOT(m2,constant0)); \
      m4 = XOR(m4,ANDNOT(m6,constant1)); \
      a0 = XOR(constant0,AND(m0,m1));    \
      a1 = XOR(constant1,AND(m4,m5));    \
      m0 = XOR(m0,AND(m3,m2));           \
      m4 = XOR(m4,AND(m7,m6));           \
      m3 = XOR(m3,ANDNOT(m1,m2));        \
      m7 = XOR(m7,ANDNOT(m5,m6));        \
      m1 = XOR(m1,AND(m0,m2));           \
      m5 = XOR(m5,AND(m4,m6));           \
      m2 = XOR(m2,ANDNOT(m3,m0));        \
      m6 = XOR(m6,ANDNOT(m7,m4));        \
      m0 = XOR(m0,OR(m1,m3));            \
      m4 = XOR(m4,OR(m5,m7));            \
      m3 = XOR(m3,AND(m1,m2));           \
      m7 = XOR(m7,AND(m5,m6));           \
      m2 = XOR(m2,a0);                   \
      m6 = XOR(m6,a1);                   \
      m1 = XOR(m1,AND(a0,m0));           \
      m5 = XOR(m5,AND(a1,m4));

/* The linear transform of the (7*i+0)th round*/
#define lineartransform_R00(m0,m1,m2,m3,m4,m5,m6,m7)         \
      /*MDS layer*/                                          \
      L(m0,m1,m2,m3,m4,m5,m6,m7);                            \
      /*swapping bit 2i with bit 2i+1 for m4,m5,m6 and m7 */ \
      m4 = SWAP1(m4); m5 = SWAP1(m5); m6 = SWAP1(m6); m7 = SWAP1(m7); 

/* The linear transform of the (7*i+1)th round*/
#define lineartransform_R01(m0,m1,m2,m3,m4,m5,m6,m7)         \
      /*MDS layer*/                                          \
      L(m0,m1,m2,m3,m4,m5,m6,m7);                            \
      /*swapping bit 4i||4i+1 with bit 4i+2||4i+3 for m4,m5,m6 and m7 */  \
      m4 = SWAP2(m4); m5 = SWAP2(m5); m6 = SWAP2(m6); m7 = SWAP2(m7);

/* The linear transform of the (7*i+2)th round*/
#define lineartransform_R02(m0,m1,m2,m3,m4,m5,m6,m7)         \
      /*MDS layer*/                                          \
      L(m0,m1,m2,m3,m4,m5,m6,m7);                            \
      /*swapping bits 8i||8i+1||8i+2||8i+3 with bits 8i+4||8i+5||8i+6||8i+7 for m4,m5,m6 and m7*/      \
      m4 = SWAP4(m4); m5 = SWAP4(m5); m6 = SWAP4(m6); m7 = SWAP4(m7);

/* The linear transform of the (7*i+3)th round*/
#define lineartransform_R03(m0,m1,m2,m3,m4,m5,m6,m7)         \
      /*MDS layer*/                                          \
      L(m0,m1,m2,m3,m4,m5,m6,m7);                            \
      /*swapping bits 16i||16i+1||...||16i+7 with bits 16i+8||16i+9||...||16i+15 for m4,m5,m6 and m7*/  \
      m4 = SWAP8(m4); m5 = SWAP8(m5); m6 = SWAP8(m6); m7 = SWAP8(m7);
      
/* The linear transform of the (7*i+4)th round*/
#define lineartransform_R04(m0,m1,m2,m3,m4,m5,m6,m7)  \
      /*MDS layer*/                                   \
      L(m0,m1,m2,m3,m4,m5,m6,m7);                     \
      /*swapping bits 32i||32i+1||...||32i+15 with bits 32i+16||32i+17||...||32i+31 for m0,m1,m2 and m3*/  \
      m4 = SWAP16(m4); m5 = SWAP16(m5); m6 = SWAP16(m6); m7 = SWAP16(m7);

/* The linear transform of the (7*i+5)th round -- faster*/
#define lineartransform_R05(m0,m1,m2,m3,m4,m5,m6,m7)  \
      /*MDS layer*/                                   \
      L(m0,m1,m2,m3,m4,m5,m6,m7);                     \
      /*swapping bits 64i||64i+1||...||64i+31 with bits 64i+32||64i+33||...||64i+63 for m0,m1,m2 and m3*/  \
      m4 = SWAP32(m4); m5 = SWAP32(m5); m6 = SWAP32(m6); m7 = SWAP32(m7);   

/* The linear transform of the (7*i+6)th round -- faster*/
#define lineartransform_R06(m0,m1,m2,m3,m4,m5,m6,m7)  \
      /*MDS layer*/                                   \
      L(m0,m1,m2,m3,m4,m5,m6,m7);                     \
      /*swapping bits 128i||128i+1||...||128i+63 with bits 128i+64||128i+65||...||128i+127 for m0,m1,m2 and m3*/  \
      m4 = SWAP64(m4); m5 = SWAP64(m5); m6 = SWAP64(m6); m7 = SWAP64(m7);       

/*the round function of E8 */
#define round_function(nn,r)                                                              \
      SS(y0,y2,y4,y6,y1,y3,y5,y7, LOAD(E8_bitslice_roundconstant[r]), LOAD(E8_bitslice_roundconstant[r]+16) ); \
      lineartransform_R##nn(y0,y2,y4,y6,y1,y3,y5,y7);     

/*the last half round of E8 */
#define last_half_round(r)                                                               \
      SS(y0,y2,y4,y6,y1,y3,y5,y7, LOAD(E8_bitslice_roundconstant[r]), LOAD(E8_bitslice_roundconstant[r]+16) ); 

/*the compression function F8 */
void F8(hashState *state) 
{
      uint64 i;
      word128  y0,y1,y2,y3,y4,y5,y6,y7;
      word128  a0,a1;

      y0 = state->x0;
      y1 = state->x1;
      y2 = state->x2;
      y3 = state->x3;
      y4 = state->x4;
      y5 = state->x5;
      y6 = state->x6;
      y7 = state->x7;

      /*xor the 512-bit message with the fist half of the 1024-bit hash state*/
      y0 = XOR(y0, LOAD(state->buffer));
      y1 = XOR(y1, LOAD(state->buffer+16));
      y2 = XOR(y2, LOAD(state->buffer+32));
      y3 = XOR(y3, LOAD(state->buffer+48));

      /*perform 35.5 rounds*/
      for (i = 0; i < 35; i = i+7) {
            round_function(00,i);
            round_function(01,i+1);
            round_function(02,i+2);
            round_function(03,i+3);
            round_function(04,i+4);
            round_function(05,i+5);
            round_function(06,i+6);
      }

      last_half_round(35);	

      /*xor the 512-bit message with the second half of the 1024-bit hash state*/
      y4 = XOR(y4, LOAD(state->buffer));
      y5 = XOR(y5, LOAD(state->buffer+16));
      y6 = XOR(y6, LOAD(state->buffer+32));
      y7 = XOR(y7, LOAD(state->buffer+48));

      state->x0 = y0;
      state->x1 = y1;
      state->x2 = y2;
      state->x3 = y3;
      state->x4 = y4;
      state->x5 = y5;
      state->x6 = y6;
      state->x7 = y7;
}

/*before hashing a message, initialize the hash state as H0 */
HashReturn Init(hashState *state, int hashbitlen) 
{
      state->hashbitlen = hashbitlen;

      /*initialize the initial hash value of JH*/
      /*load the intital hash value into state*/

      switch(hashbitlen) 
      { 
          case 224:
              state->x0 = LOAD(JH224_H0);
              state->x1 = LOAD(JH224_H0+16);
              state->x2 = LOAD(JH224_H0+32);
              state->x3 = LOAD(JH224_H0+48);
              state->x4 = LOAD(JH224_H0+64);
              state->x5 = LOAD(JH224_H0+80);
              state->x6 = LOAD(JH224_H0+96);
              state->x7 = LOAD(JH224_H0+112);
              break;

          case 256:
              state->x0 = LOAD(JH256_H0);
              state->x1 = LOAD(JH256_H0+16);
              state->x2 = LOAD(JH256_H0+32);
              state->x3 = LOAD(JH256_H0+48);
              state->x4 = LOAD(JH256_H0+64);
              state->x5 = LOAD(JH256_H0+80);
              state->x6 = LOAD(JH256_H0+96);
              state->x7 = LOAD(JH256_H0+112);
              break;

          case 384: 
              state->x0 = LOAD(JH384_H0);
              state->x1 = LOAD(JH384_H0+16);
              state->x2 = LOAD(JH384_H0+32);
              state->x3 = LOAD(JH384_H0+48);
              state->x4 = LOAD(JH384_H0+64);
              state->x5 = LOAD(JH384_H0+80);
              state->x6 = LOAD(JH384_H0+96);
              state->x7 = LOAD(JH384_H0+112);
              break; 

          case 512:     
              state->x0 = LOAD(JH512_H0);
              state->x1 = LOAD(JH512_H0+16);
              state->x2 = LOAD(JH512_H0+32);
              state->x3 = LOAD(JH512_H0+48);
              state->x4 = LOAD(JH512_H0+64);
              state->x5 = LOAD(JH512_H0+80);
              state->x6 = LOAD(JH512_H0+96);
              state->x7 = LOAD(JH512_H0+112);
              break;
      }

      return(SUCCESS);
}

/*hash each 512-bit message block, except the last partial block*/
HashReturn Update(hashState *state, const BitSequence *data, DataLength databitlen) 
{
      DataLength i;

      state->databitlen = databitlen;

      for (i = 0; (i+512) <= databitlen; i = i+512) {
          memcpy(state->buffer, data + (i >> 3), 64);
          F8(state);
      }

      /*storing the partial block into buffer, assume that -- if part of the last byte is not part of the message, then that part consists of 0 bits*/
      if ( (databitlen & 0x1ff) > 0) {
          memset(state->buffer,0,64);
          if ((databitlen & 7) == 0) memcpy(state->buffer, data + ((databitlen >> 9) << 6), (databitlen & 0x1ff) >> 3);
          else memcpy(state->buffer, data + ((databitlen >> 9) << 6), ((databitlen & 0x1ff) >> 3)+1);
      }

      return(SUCCESS);
}

/*pad the message, process the padded block(s), truncate the hash value H to obtain the message digest*/
HashReturn Final(hashState *state, BitSequence *hashval) 
{
      DATA_ALIGN16(unsigned char t[64]);

      if ( (state->databitlen & 0x1ff) == 0 ) 
      {
          /*pad the message when databitlen is multiple of 512 bits, then process the padded block*/
          memset(state->buffer,0,64);
          state->buffer[0] = 0x80;
          state->buffer[63] = state->databitlen & 0xff;
          state->buffer[62] = (state->databitlen >> 8) & 0xff;
          state->buffer[61] = (state->databitlen >> 16) & 0xff;
          state->buffer[60] = (state->databitlen >> 24) & 0xff;
          state->buffer[59] = (state->databitlen >> 32) & 0xff;
          state->buffer[58] = (state->databitlen >> 40) & 0xff;
          state->buffer[57] = (state->databitlen >> 48) & 0xff;
          state->buffer[56] = (state->databitlen >> 56) & 0xff;
          F8(state);
      }
      else  {
          /*pad and process the partial block when databitlen is not multiple of 512 bits, then hash the padded blocks*/
          state->buffer[((state->databitlen & 0x1ff) >> 3)] |= 1 << (7- (state->databitlen & 7));
          F8(state);
          memset(state->buffer,0,64);
          state->buffer[63] = state->databitlen & 0xff;
          state->buffer[62] = (state->databitlen >> 8) & 0xff;
          state->buffer[61] = (state->databitlen >> 16) & 0xff;
          state->buffer[60] = (state->databitlen >> 24) & 0xff;
          state->buffer[59] = (state->databitlen >> 32) & 0xff;
          state->buffer[58] = (state->databitlen >> 40) & 0xff;
          state->buffer[57] = (state->databitlen >> 48) & 0xff;
          state->buffer[56] = (state->databitlen >> 56) & 0xff;
          F8(state);
      }

      /*truncting the final hash value to generate the message digest*/
      STORE(state->x4,t);
      STORE(state->x5,t+16);
      STORE(state->x6,t+32);
      STORE(state->x7,t+48);

      switch (state->hashbitlen) 
      {
          case 224: memcpy(hashval,t+36,28); break;
          case 256: memcpy(hashval,t+32,32); break;
          case 384: memcpy(hashval,t+16,48); break;
          case 512: memcpy(hashval,t,64);    break;
      }

      return(SUCCESS);
}

/* hash a message, 
   three inputs: message digest size in bits (hashbitlen); message (data); message length in bits (databitlen) 
   one output:   message digest (hashval)
*/
HashReturn Hash(int hashbitlen, const BitSequence *data,DataLength databitlen, BitSequence *hashval) 
{
      hashState state;

      if ( hashbitlen == 224 || hashbitlen == 256 || hashbitlen == 384 || hashbitlen == 512 ) 
      {	
          Init(&state, hashbitlen);
          Update(&state, data, databitlen);
          Final(&state, hashval);
          return SUCCESS;
      }
      else 
          return(BAD_HASHLEN);
}
