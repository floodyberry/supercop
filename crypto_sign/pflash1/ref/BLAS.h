/*
 * $Id: BLAS.h 955 2008-05-03 14:39:31Z owenhsin $
 */

#ifndef _BLAS_H
#define _BLAS_H

#include "GF16.h"
#include "GF256.h"
#include <stdio.h>

/**
 * \brief		Compute matrix multiplication, C = A * B,
 *			here A and B are both n by n matrix
 */
void BLAS_prod_A(int dim, byte *C, byte *A, byte *B);

/**
 * \brief		Perform in place element row operation on matrix A,
 *			A[j][k] += m*A[i][k]
 */
void BLAS_elemRowOpIII(int dim, byte *A, int i, int j, byte m);

/**
 * \brief		Perform Gaussian elimination on matrix A, and find 
 *			homogeneous solution.
 */
int BLAS_gusElimHomoEqs(int dim, byte *A, byte *res);

/**
 * \brief		Perform diagonal matrix inversion
 */
void BLAS_ivsD(int dim, byte *Di, byte *D);

/**
 * \brief		Perform lower matrix inversion
 */
void BLAS_ivsL(int dim, byte *Li, byte *L);

/**
 * \brief		Perform upper matrix inversion
 */
void BLAS_ivsU(int dim, byte *Ui, byte *U);

/**
 * \brief		Generate an invertible GF(16) matrix pair, 
 *			the matrixes are in compact form.
 *			M and Mi each require dim*dim/2 bytes.
 *
 *			If the matrix is stored in normal form, 
 *			(dim by dim), one element per byte, denoted MM. 
 *			We use [lower byte, higher byte] to 
 *			represent a byte. Then, 
 *			M[0] = logtab[MM[0][0],MM[1][0]]
 *			M[1] = logtab[MM[0][1],MM[1][1]]
 *			M[2] = logtab[MM[2][0],MM[3][0]]
 *			M[3] = logtab[MM[2][1],MM[3][1]]
 *			...
 *			M[dim]   = logtab[MM[0][2],MM[1][2]]
 *			M[dim+1] = logtab[MM[0][3],MM[1][3]]
 *			...
 */
void BLAS_genMatGF16(int dim, byte *M, byte *Mi);

/**
 * \brief		Generate random GF(256) vector with length dim
 */
void BLAS_genVec(int dim, byte *V);

/**
 * \brief		Perform affine transformation, b = Ax + c, 
 *			where A is generate by BLAS_genMatGF16
 */
void BLAS_affineGF16(int dim, byte *b, byte *A, byte *x, byte *c);

/**
 * \brief		Perform inverse affine transformation, b = A(x+c), 
 *			where A is generated by BLAS_genMatGF16
 */
void BLAS_ivsAffineGF16(int dim, byte *b, byte *A, byte *x, byte *c);

/**
 * \brief		Perform partial linear transformation, 
 *			only compute last pSize rows, where x is in
 *			log form
 */
int BLAS_pLinearGF16(int dim, byte *b, byte *A, byte *y, int pSize);

/**
 * \brief		Perform partial linear transformation, 
 *			only compute first (dim-pSize) rows, where
 *			x is in log form
 */
void BLAS_rLinearGF16(int dim, byte *b, byte *A, byte *y, int pSize);

/**
 * \brief		Perform all linear transformation, 
 *			where x is in log form
 */
void BLAS_aLinearGF16(int dim, byte *b, byte *A, byte *y);

/**
 * \brief		Dump the dim_h by dim_w matrix to stdout
 */
void BLAS_dumpMat(int dim_h, int dim_w, byte *A);

/*
 * \brief		Dump the dim long vector
 */
void BLAS_dumpVec(int dim, byte *V);

#endif /* _BLAS_H */

/*
 * BLAS.h
 */
