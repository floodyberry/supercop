/*
 * crypto_dh/try.c version 20140423
 * D. J. Bernstein
 * Public domain.
 * Auto-generated by trygen.py; do not edit.
 */

#include "crypto_dh.h"
#include "try.h"

const char *primitiveimplementation = crypto_dh_IMPLEMENTATION;

#ifdef SMALL
#define LOOPS 64
#else
#define LOOPS 512
#endif

static unsigned char *a;
static unsigned char *b;
static unsigned char *c;
static unsigned char *d;
static unsigned char *e;
static unsigned char *f;
static unsigned char *a2;
static unsigned char *b2;
static unsigned char *c2;
static unsigned char *d2;
static unsigned char *e2;
static unsigned char *f2;
#define alen crypto_dh_SECRETKEYBYTES
#define blen crypto_dh_SECRETKEYBYTES
#define clen crypto_dh_PUBLICKEYBYTES
#define dlen crypto_dh_PUBLICKEYBYTES
#define elen crypto_dh_BYTES
#define flen crypto_dh_BYTES

void preallocate(void)
{
#ifdef RAND_R_PRNG_NOT_SEEDED
  RAND_status();
#endif
}

void allocate(void)
{
  unsigned long long alloclen = 0;
  if (alloclen < crypto_dh_SECRETKEYBYTES) alloclen = crypto_dh_SECRETKEYBYTES;
  if (alloclen < crypto_dh_SECRETKEYBYTES) alloclen = crypto_dh_SECRETKEYBYTES;
  if (alloclen < crypto_dh_PUBLICKEYBYTES) alloclen = crypto_dh_PUBLICKEYBYTES;
  if (alloclen < crypto_dh_PUBLICKEYBYTES) alloclen = crypto_dh_PUBLICKEYBYTES;
  if (alloclen < crypto_dh_BYTES) alloclen = crypto_dh_BYTES;
  if (alloclen < crypto_dh_BYTES) alloclen = crypto_dh_BYTES;
  a = alignedcalloc(alloclen);
  b = alignedcalloc(alloclen);
  c = alignedcalloc(alloclen);
  d = alignedcalloc(alloclen);
  e = alignedcalloc(alloclen);
  f = alignedcalloc(alloclen);
  a2 = alignedcalloc(alloclen);
  b2 = alignedcalloc(alloclen);
  c2 = alignedcalloc(alloclen);
  d2 = alignedcalloc(alloclen);
  e2 = alignedcalloc(alloclen);
  f2 = alignedcalloc(alloclen);
}

void predoit(void)
{
}

void doit(void)
{
  crypto_dh_keypair(c,a);
  crypto_dh_keypair(d,b);
  crypto_dh(e,d,a);
  crypto_dh(f,c,b);
}

void test(void)
{
  unsigned long long loop;
  
  for (loop = 0;loop < LOOPS;++loop) {
    
    output_prepare(c2,c,clen);
    output_prepare(a2,a,alen);
    if (crypto_dh_keypair(c,a) != 0) fail("crypto_dh_keypair returns nonzero");
    checksum(c,clen);
    checksum(a,alen);
    output_compare(c2,c,clen,"crypto_dh_keypair");
    output_compare(a2,a,alen,"crypto_dh_keypair");
    
    output_prepare(d2,d,dlen);
    output_prepare(b2,b,blen);
    if (crypto_dh_keypair(d,b) != 0) fail("crypto_dh_keypair returns nonzero");
    checksum(d,dlen);
    checksum(b,blen);
    output_compare(d2,d,dlen,"crypto_dh_keypair");
    output_compare(b2,b,blen,"crypto_dh_keypair");
    
    output_prepare(e2,e,elen);
    memcpy(d2,d,dlen);
    double_canary(d2,d,dlen);
    memcpy(a2,a,alen);
    double_canary(a2,a,alen);
    if (crypto_dh(e,d,a) != 0) fail("crypto_dh returns nonzero");
    checksum(e,elen);
    output_compare(e2,e,elen,"crypto_dh");
    input_compare(d2,d,dlen,"crypto_dh");
    input_compare(a2,a,alen,"crypto_dh");
    
    double_canary(e2,e,elen);
    double_canary(d2,d,dlen);
    double_canary(a2,a,alen);
    if (crypto_dh(e2,d2,a2) != 0) fail("crypto_dh returns nonzero");
    if (memcmp(e2,e,elen) != 0) fail("crypto_dh is nondeterministic");
    
    double_canary(e2,e,elen);
    double_canary(d2,d,dlen);
    double_canary(a2,a,alen);
    if (crypto_dh(d2,d2,a) != 0) fail("crypto_dh with d=e overlap returns nonzero");
    if (memcmp(d2,e,elen) != 0) fail("crypto_dh does not handle d=e overlap");
    memcpy(d2,d,dlen);
    if (crypto_dh(a2,d,a2) != 0) fail("crypto_dh with a=e overlap returns nonzero");
    if (memcmp(a2,e,elen) != 0) fail("crypto_dh does not handle a=e overlap");
    memcpy(a2,a,alen);
    
    output_prepare(f2,f,flen);
    memcpy(c2,c,clen);
    double_canary(c2,c,clen);
    memcpy(b2,b,blen);
    double_canary(b2,b,blen);
    if (crypto_dh(f,c,b) != 0) fail("crypto_dh returns nonzero");
    checksum(f,flen);
    output_compare(f2,f,flen,"crypto_dh");
    input_compare(c2,c,clen,"crypto_dh");
    input_compare(b2,b,blen,"crypto_dh");
    
    double_canary(f2,f,flen);
    double_canary(c2,c,clen);
    double_canary(b2,b,blen);
    if (crypto_dh(f2,c2,b2) != 0) fail("crypto_dh returns nonzero");
    if (memcmp(f2,f,flen) != 0) fail("crypto_dh is nondeterministic");
    
    double_canary(f2,f,flen);
    double_canary(c2,c,clen);
    double_canary(b2,b,blen);
    if (crypto_dh(c2,c2,b) != 0) fail("crypto_dh with c=f overlap returns nonzero");
    if (memcmp(c2,f,flen) != 0) fail("crypto_dh does not handle c=f overlap");
    memcpy(c2,c,clen);
    if (crypto_dh(b2,c,b2) != 0) fail("crypto_dh with b=f overlap returns nonzero");
    if (memcmp(b2,f,flen) != 0) fail("crypto_dh does not handle b=f overlap");
    memcpy(b2,b,blen);
    
    if (memcmp(f,e,elen) != 0) fail("crypto_dh not associative");
  }
}
